<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LLM Benchmark Results</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css?v=2">
    <meta name="description"
        content="Results from a Swedish evaluation benchmark testing various LLMs on Swedish language tasks." />
</head>

<body>
    <div class="container">
        <div class="header-accent"></div>
        <h1>Swedish LLM Benchmark Results</h1>
        <div class="intro">
            <p>This page displays the results from a Swedish evaluation benchmark. The benchmark tests various LLMs on
                several Swedish tasks.</p>
        </div>
        <div class="table-wrap">
            <table id="results-table">
                <thead></thead>
                <tbody></tbody>
            </table>
            <hr>
            <div class="footer">
                <p>The evaluation is available on <a href="https://huggingface.co/datasets/ekgren/swedish_skolprov"
                        target="_blank" rel="noopener">Hugging Face</a>.</p>
                <p><strong>The tests</strong>
                <p>
                    <strong>Högskoleprovet (HP VERB)</strong> - <a
                        href="https://huggingface.co/datasets/Ekgren/swedish_skolprov/viewer/h%C3%B6gskoleprovet"
                        target="_blank" rel="noopener">View data on huggingface</a>
                    <br>| <a href="https://www.studera.nu/hogskoleprov/om/forbereda/tidigare/" target="_blank"
                        rel="noopener">www.studera.nu/hogskoleprov/om/forbereda/tidigare/</a>
                </p>
                <p>
                    <strong>Matematik- och fysikprovet</strong> - <a
                        href="https://huggingface.co/datasets/Ekgren/swedish_skolprov/viewer/matematik_och_fysikprovet"
                        target="_blank" rel="noopener">View data on huggingface</a>
                    <br>| <a
                        href="https://www.kth.se/mattefysik/matematik-och-fysikprovet/matematik-och-fysikprovet-1.1233988"
                        target="_blank"
                        rel="noopener">www.kth.se/mattefysik/matematik-och-fysikprovet/matematik-och-fysikprovet-1.1233988</a>
                </p>
                <p>
                    <strong>Kunskapsprov läkare</strong> - <a
                        href="https://huggingface.co/datasets/Ekgren/swedish_skolprov/viewer/kunskapsprov_lakare"
                        target="_blank" rel="noopener">View data on huggingface</a>
                    <br>| <a href="https://www.umu.se/utbildning/sok/kunskapsprov/kunskapsprov-for-lakare/"
                        target="_blank"
                        rel="noopener">www.umu.se/utbildning/sok/kunskapsprov/kunskapsprov-for-lakare/</a>
                    <br>| <a
                        href="https://www.umu.se/utbildning/sok/kunskapsprov/kunskapsprov-for-lakare/teoretiskt-delprov/"
                        target="_blank"
                        rel="noopener">www.umu.se/utbildning/sok/kunskapsprov/kunskapsprov-for-lakare/teoretiskt-delprov/</a>
                </p>
                <p>
                    <strong>Kunskapsprov tandläkare</strong> - <a
                        href="https://huggingface.co/datasets/Ekgren/swedish_skolprov/viewer/kunskapsprov_tandlakare"
                        target="_blank" rel="noopener">View data on huggingface</a>
                    <br>| <a
                        href="https://ki.se/dentmed/utbildning/kunskapsprov-for-tandlakare-med-utbildning-fran-lander-utanfor-euees"
                        target="_blank"
                        rel="noopener">www.ki.se/dentmed/utbildning/kunskapsprov-for-tandlakare-med-utbildning-fran-lander-utanfor-euees</a>
                </p>

                <p>
                    <strong>Kunskapsprov farmaceuter (APOTEKARE)</strong> - <a
                        href="https://huggingface.co/datasets/Ekgren/swedish_skolprov/viewer/kunskapsprov_apotekare_2024-01-23_del_a"
                        target="_blank" rel="noopener">View data on huggingface</a>
                    <br>| <a
                        href="https://www.uu.se/utbildning/anmalan-och-antagning/utlandsk-utbildning/arbeta-som-farmaceut-i-sverige/kunskapsprov"
                        target="_blank"
                        rel="noopener">www.uu.se/utbildning/anmalan-och-antagning/utlandsk-utbildning/arbeta-som-farmaceut-i-sverige/kunskapsprov</a>
                    <br>| <a
                        href="https://www.uu.se/utbildning/anmalan-och-antagning/utlandsk-utbildning/arbeta-som-farmaceut-i-sverige/kunskapsprov/forberedelser-till-det-teoretiska-kunskapsprovet"
                        target="_blank"
                        rel="noopener">www.uu.se/utbildning/anmalan-och-antagning/utlandsk-utbildning/arbeta-som-farmaceut-i-sverige/kunskapsprov/forberedelser-till-det-teoretiska-kunskapsprovet</a>
                </p>
                <p>
                    <strong>Kunskapsprov audionomer</strong> - <a
                        href="https://huggingface.co/datasets/Ekgren/swedish_skolprov/viewer/kunskapsprov_audionomer"
                        target="_blank" rel="noopener">View data on huggingface</a>
                    <br>| <a href="https://www.gu.se/studera/hitta-utbildning/kunskapsprov-audionomer" target="_blank"
                        rel="noopener">www.gu.se/studera/hitta-utbildning/kunskapsprov-audionomer</a>
                </p>
                </p>
                <p>Created by Ariel Ekgren.</p>
            </div>
        </div>
        <script>
            /**
             * =================================================================================
             *  MANAGER SUMMARY
             * =================================================================================
             *  How this page works (The "Kitchen" Analogy):
             *
             *  1. THE INGREDIENTS (Data Loading)
             *     We fetch the raw test results from a file called 'data/model_table.json'.
             *
             *  2. THE RECIPE (Configuration)
             *     We look at our TABLE_CONFIG below to decide:
             *     - Which columns to show first?
             *     - How wide should they be?
             *     - How should we rename complex technical IDs into human-readable labels?
             *
             *  3. PREPARATION (Data Processing)
             *     We chop and mix the raw data into a clean list of rows that match our
             *     columns. We handle missing scores by showing '-' and putting them
             *     at the bottom.
             *
             *  4. SERVING (Rendering)
             *     Finally, we draw the table on the screen. We also add interactivity
             *     so you can click headers to sort the "dishes" (models).
             * =================================================================================
             */

            // --- 1. THE RECIPE (Configuration) ---
            // Everything about how the table looks and behaves is defined here.

            const TABLE_CONFIG = {
                // Where do we get the ingredients?
                dataSource: 'data/model_table.json', // URL to the JSON file

                // A. FIXED COLUMNS
                // These columns ALWAYS appear at the start of the table.
                fixedColumns: [
                    {
                        id: 'model',
                        label: 'Model',
                        widthPercent: 25,
                        type: 'text'      // Just text
                    },
                    {
                        id: 'average',
                        label: 'Average',
                        widthPercent: 6,
                        type: 'number'    // Sorts numerically
                    },
                    {
                        id: 'open_weights',
                        label: 'Open Weights',
                        widthPercent: 5,
                        type: 'text'
                    },
                    {
                        id: 'thinking',
                        label: 'Thinking',
                        widthPercent: 4,
                        type: 'icon'
                    }
                ],

                // B. TEST COLUMN RENAMING
                // Map difficult ID names to nice human-readable labels.
                columnLabels: {
                    '2024-10-20': 'HP Verb',
                    'kunskapsprov_apotekare_2024-01-23_del_a': 'Apotekare',
                    'kunskapsprov_audionomer_2023-10-17-teoretiskt-delprov': 'Audionomer',
                    'kunskapsprov_läkare_2024-11-26_mcq-140': 'Läkare',
                    'kunskapsprov_tandläkare_TDL-2411': 'Tandläkare',
                    'matematik_och_fysikprovet': 'Matematik och Fysikprovet'
                },

                // C. TEST ORDER
                // We want these specific tests to appear in this order after the fixed columns.
                // Any new test found in the data that isn't listed here will be added
                // automatically at the end, sorted alphabetically.
                preferredTestOrder: [
                    '2024-10-20',
                    'kunskapsprov_apotekare_2024-01-23_del_a',
                    'kunskapsprov_audionomer_2023-10-17-teoretiskt-delprov',
                    'kunskapsprov_läkare_2024-11-26_mcq-140',
                    'kunskapsprov_tandläkare_TDL-2411',
                    'matematik_och_fysikprovet'
                ],

                // D. SPECIAL TYPES
                // If a column needs special handling (like an icon), define it here.
                specialTypes: {}
            };

            // --- 2. THE CHEF (Utilities) ---

            const Utils = {
                // Turn "kunskapsprov_läkare..." into "Läkare"
                getLabelForColumn(id) {
                    // 1. Is it explicitly renamed in config?
                    if (TABLE_CONFIG.columnLabels[id]) {
                        return TABLE_CONFIG.columnLabels[id];
                    }

                    // 2. Otherwise, clean it up automatically
                    return id
                        .replaceAll('_', ' ')
                        .replaceAll('-', ' ')
                        .replace(/\b\d{4}-\d{2}-\d{2}\b/g, '') // Remove dates
                        .replace(/\s+/g, ' ')                  // Collapse spaces
                        .trim()
                        .replace(/^\w/, (c) => c.toUpperCase()); // Capitalize first letter
                },

                // Clean up model names
                formatModelName(rawName) {
                    return (rawName || '').replaceAll('/', '-');
                }
            };

            // --- 3. PREPARATION (Data Processing) ---
            // Transforms raw JSON into a clean structure our renderer understands.

            class ViewModelBuilder {
                constructor(rawItems) {
                    this.rawItems = rawItems;
                }

                build() {
                    // Step 1: Figure out what columns we actually have in the data
                    const dynamicTestKeys = this._discoverTestKeys();

                    // Step 2: Combine Fixed Columns + Dynamic Test Columns
                    // We start with the fixed ones defined in CONFIG
                    const headers = [...TABLE_CONFIG.fixedColumns];

                    // Then we add the discovered tests
                    dynamicTestKeys.forEach(key => {
                        headers.push({
                            id: key,
                            label: Utils.getLabelForColumn(key),
                            // If it's the 'thinking' column, use icon type, otherwise it's a ratio (score/total)
                            type: TABLE_CONFIG.specialTypes[key] || 'ratio',
                            sortable: true
                        });
                    });

                    // Step 3: Process every row to match these headers
                    const rows = this.rawItems.map(item => this._processRow(item, headers));

                    return { headers, rows };
                }

                _discoverTestKeys() {
                    if (!this.rawItems.length) return [];

                    // Look at all items to find every possible test key
                    const allKeysSet = new Set();
                    this.rawItems.forEach(obj => {
                        Object.keys(obj).forEach(k => {
                            // Skip metadata keys
                            if (['sampled_model_name', 'open_weights', 'thinking', 'average_score'].includes(k)) {
                                return;
                            }

                            // If it looks like a test result object (has 'points'), keep it
                            if (typeof obj[k] === 'object' && obj[k] !== null && 'points' in obj[k]) {
                                allKeysSet.add(k);
                            }
                        });
                    });

                    // Sort them according to our preferred order
                    const keys = Array.from(allKeysSet);
                    const preferred = TABLE_CONFIG.preferredTestOrder.filter(k => allKeysSet.has(k));
                    const others = keys.filter(k => !TABLE_CONFIG.preferredTestOrder.includes(k)).sort();

                    return [...preferred, ...others];
                }

                _processRow(item, headers) {
                    const rowData = {
                        cells: {}
                    };

                    headers.forEach(header => {
                        const key = header.id;
                        let cellValue = { display: '-', value: -1, classes: [] };

                        // CASE A: Model Name
                        if (key === 'model') {
                            cellValue.display = Utils.formatModelName(item['sampled_model_name']);
                            cellValue.value = cellValue.display;
                        }
                        // CASE B: Average Score
                        else if (key === 'average') {
                            const val = item['average_score'] || 0;
                            cellValue.display = val.toFixed(2);
                            cellValue.value = val;
                            cellValue.classes.push('num');
                        }
                        // CASE C: Open Weights
                        else if (key === 'open_weights') {
                            cellValue.display = item['open_weights'] || '-';
                            cellValue.value = cellValue.display;
                        }
                        // CASE D: Thinking (Special)
                        else if (key === 'thinking') {
                            const val = item['thinking'];
                            cellValue.display = val || '-';
                            cellValue.value = 0;
                            if (val) {
                                cellValue.isAttribute = true;
                                cellValue.attrName = 'data-thinking';
                                cellValue.attrValue = 'true';
                            } else {
                                cellValue.classes.push('num');
                            }
                        }
                        // CASE E: Regular Test Result
                        else {
                            const entry = item[key];
                            if (entry && typeof entry === 'object' && 'points' in entry) {
                                const p = parseFloat(entry.points);
                                const t = parseFloat(entry.total);
                                if (Number.isFinite(p) && Number.isFinite(t) && t > 0) {
                                    cellValue.display = `${p}/${t}`;
                                    cellValue.value = p / t; // Ratio for sorting
                                    cellValue.classes.push('num');
                                } else {
                                    cellValue.classes.push('num'); // Empty but numeric alignment
                                }
                            } else {
                                cellValue.classes.push('num');
                            }
                        }

                        rowData.cells[key] = cellValue;
                    });

                    return rowData;
                }
            }

            // --- 4. SERVING (Rendering) ---
            // Takes the prepared View Model and draws it into the HTML table.

            class TableRenderer {
                constructor(tableId) {
                    this.table = document.getElementById(tableId);
                    if (!this.table) throw new Error(`Table with id ${tableId} not found`);
                    this.thead = this.table.tHead || this.table.createTHead();
                    this.tbody = this.table.tBodies[0] || this.table.createTBody();
                }

                render(viewModel) {
                    this.clear();

                    // 1. Draw Headers
                    this._renderHead(viewModel.headers);

                    // 2. Draw Body
                    this._renderBody(viewModel.headers, viewModel.rows);

                    // 3. Make sortable
                    this._setupInteractions();

                    // 4. Set column widths
                    this._applyLayoutConfig(viewModel.headers);
                }

                clear() {
                    this.thead.innerHTML = '';
                    this.tbody.innerHTML = '';
                }

                _renderHead(headers) {
                    const row = document.createElement('tr');
                    headers.forEach((h, idx) => {
                        const th = document.createElement('th');
                        th.textContent = h.label;

                        // Add class for specific styling (like numbers aligning right)
                        if (h.type === 'number' || h.type === 'ratio') {
                            th.classList.add('num');
                        }

                        // Accessibility & Sorting interactions
                        th.setAttribute('role', 'button');
                        th.setAttribute('tabindex', '0');
                        th.dataset.colIndex = idx;

                        row.appendChild(th);
                    });
                    this.thead.appendChild(row);
                }

                _renderBody(headers, rows) {
                    rows.forEach(row => {
                        const tr = document.createElement('tr');

                        headers.forEach(h => {
                            const td = document.createElement('td');
                            const cellData = row.cells[h.id];

                            td.textContent = cellData.display;

                            // Apply CSS classes (e.g., 'num')
                            if (cellData.classes) {
                                cellData.classes.forEach(c => td.classList.add(c));
                            }

                            // Apply special attributes (like for the thinking icon)
                            if (cellData.isAttribute) {
                                td.setAttribute(cellData.attrName, cellData.attrValue);
                            }

                            // Store raw value for sorting
                            td.dataset.value = cellData.value;

                            tr.appendChild(td);
                        });

                        this.tbody.appendChild(tr);
                    });
                }

                _setupInteractions() {
                    const ths = this.thead.querySelectorAll('th');
                    ths.forEach(th => {
                        const onClick = () => this.sort(parseInt(th.dataset.colIndex));
                        th.addEventListener('click', onClick);
                        th.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                onClick();
                            }
                        });
                    });
                }

                _applyLayoutConfig(headers) {
                    const headerRow = this.thead.rows[0];
                    if (!headerRow) return;

                    // Calculate total width used by fixed columns
                    let usedWidth = 0;
                    let fixedCount = 0;

                    headers.forEach(h => {
                        if (h.widthPercent) {
                            usedWidth += h.widthPercent;
                            fixedCount++;
                        }
                    });

                    // Distribute remaining width among the dynamic test columns
                    const remainingWidth = 100 - usedWidth;
                    const dynamicCount = headers.length - fixedCount;
                    const dynamicWidth = dynamicCount > 0 ? (remainingWidth / dynamicCount) : 0;

                    // Apply widths
                    headers.forEach((h, i) => {
                        const width = h.widthPercent || dynamicWidth;
                        const style = `width: ${width}%`;

                        // Apply to header
                        headerRow.cells[i].style.cssText = style;

                        // Apply to all body cells in this column
                        // (This is redundant if table-layout: fixed is used properly, 
                        // but ensures consistency across browsers/modes)
                        Array.from(this.tbody.rows).forEach(row => {
                            if (row.cells[i]) row.cells[i].style.cssText = style;
                        });
                    });
                }

                sort(columnIndex) {
                    const rows = Array.from(this.tbody.rows);
                    const th = this.thead.rows[0].cells[columnIndex];
                    const currentDir = th.classList.contains('sort-asc') ? 'asc' : th.classList.contains('sort-desc') ? 'desc' : 'none';
                    const dir = currentDir === 'asc' ? 'desc' : 'asc'; // Toggle

                    // Clear previous sort indicators
                    Array.from(this.thead.querySelectorAll('th')).forEach(h => {
                        h.classList.remove('sort-asc', 'sort-desc');
                        h.setAttribute('aria-sort', 'none');
                    });

                    // Sort!
                    rows.sort((a, b) => {
                        // Extract values we stored in data-value
                        const valA = parseFloat(a.cells[columnIndex].dataset.value);
                        const valB = parseFloat(b.cells[columnIndex].dataset.value);

                        // Compare (handling NaNs for safety, though mixed types shouldn't happen much)
                        if (!isNaN(valA) && !isNaN(valB)) {
                            return dir === 'asc' ? valA - valB : valB - valA;
                        }

                        // Fallback to text string comparison
                        const textA = a.cells[columnIndex].textContent.trim();
                        const textB = b.cells[columnIndex].textContent.trim();
                        return dir === 'asc'
                            ? textA.localeCompare(textB)
                            : textB.localeCompare(textA);
                    });

                    // Update UI
                    rows.forEach(r => this.tbody.appendChild(r));
                    th.classList.add(dir === 'asc' ? 'sort-asc' : 'sort-desc');
                    th.setAttribute('aria-sort', dir === 'asc' ? 'ascending' : 'descending');
                }
            }

            // --- 5. START THE ENGINE (Bootstrap) ---

            async function main() {
                const renderer = new TableRenderer('results-table');

                // Helper to show a simple message in the table
                const showMessage = (msg) => {
                    renderer.clear();
                    const row = renderer.thead.insertRow();
                    const th = document.createElement('th');
                    th.textContent = msg;
                    th.colSpan = 10; // Wide enough to span most tables
                    row.appendChild(th);
                };

                showMessage('Loading results...');

                try {
                    const res = await fetch(TABLE_CONFIG.dataSource, { cache: 'no-store' });
                    if (!res.ok) throw new Error('Data file missing');
                    const items = await res.json();

                    const builder = new ViewModelBuilder(items);
                    const viewModel = builder.build();

                    renderer.render(viewModel);

                    // Default Sort: Average Score, Descending
                    // We simply simulate a click or call sort. 
                    // Index 1 is typically 'Average' in our config.
                    const avgIndex = viewModel.headers.findIndex(h => h.id === 'average');
                    if (avgIndex >= 0) {
                        // Sort once to ASC, then again to DESC (default behavior of our sort toggle)
                        // Or just force it. Let's just double toggle or hack it slightly for simplicity.
                        const th = renderer.thead.rows[0].cells[avgIndex];
                        th.classList.add('sort-asc'); // Set initial state so next click/sort goes to desc
                        renderer.sort(avgIndex);
                    }

                } catch (err) {
                    console.error(err);
                    showMessage('Could not load results. Please ensure you are serving this file via a web server.');
                }
            }

            document.addEventListener('DOMContentLoaded', main);
        </script>
</body>

</html>